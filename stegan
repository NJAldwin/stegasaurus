#!/usr/bin/env python
# coding=utf-8

# Stegasaurus
###############
# aldwin
# asm
# emzee
# gkatsev

import sndhdr
import wave
import mimetypes
import getopt
import sys
import os
import numpy
from numpy.fft import fft, ifft
from numpy import array
from struct import unpack, pack
import random

DECODE = "decode"
ENCODE = "encode"
WAV = "wav"
RATE = 44100
SEED = "our cool awesome seed"
FRAMEDIST = 7
LOW_MASK = 0x0000FFFF
HIGH_MASK = 0xFFFF0000

def usage():
    print "./stegan --encode file1 file2 file3"
    print "./stegan --decode file4 file5"
    print "file1 → is input audio file, the carrier"
    print "file2 → is input message file"
    print "file3 → is output audio file"
    print "file4 → is input audio with steganography; i.e., file3"
    print "file5 → is output message file"

def main():
    try:
        mode, opts = getopt.getopt(sys.argv[1:],"",[DECODE,ENCODE])
    except:
        usage()
        exit()
    if len(mode)<1:
        usage()
        exit()
    mode = mode[0][0].strip('-')
    print mode
    nargs = 3 if mode == ENCODE else 2
    if len(opts)<nargs:
        usage()
        exit()
    print opts
    if not checkformat(opts[0], WAV, RATE):
        usage()
        exit()
    random.seed(SEED)
    if mode == ENCODE:
        encode(opts)
    else:
        decode(opts)

def encode(opts):
    print "encoding, woo"
    file1 = opts[0]
    file2 = opts[1]
    file3 = opts[2]
    if not os.path.isfile(file2):
        usage()
        exit()
    tohide = open(file2, 'rb').read()
    inaudio = wave.open(file1, 'rb')
    bytes = bytearray(tohide)
    prbytes = [b ^ random.getrandbits(8) for b in bytes]
    outaudio = wave.open(file3, 'wb')
    outaudio.setparams(inaudio.getparams())
    totalframes = inaudio.getnframes()


    # note: use fft later for mp3 compatibility
    end = len(prbytes) if len(prbytes) * FRAMEDIST < totalframes else (totalframes/7) 
    dist = (totalframes / end) - 1
    endlo = end & LOW_MASK
    endhi = (end & HIGH_MASK) >> 16
    # skip frame for marking length
    inaudio.readframes(1)
    # < : little-endian
    # h : short
    # H : unsigned short
    # using only left channel
    outframe = pack("<HH", endlo, endhi)
    outaudio.writeframes(outframe)
    for i in range(end):
        outr = prbytes[i]
        frame = unpack("<hh", inaudio.readframes(1))
        side = (i % 2) == 0
        outframe = pack("<hh", prbytes[i] if side else frame[0], frame[1] if side else prbytes[i])
        outaudio.writeframes(outframe)
        frames = bytearray(inaudio.readframes(dist))
        outaudio.writeframes(frames)

    frames = bytearray(inaudio.readframes(totalframes))
    outaudio.writeframes(frames)

    outaudio.close()
    inaudio.close()

def decode(opts):
    print "decoding, woo"
    file4 = opts[0]
    file5 = opts[1]
    inaudio = wave.open(file4, 'rb')
    outmsg = open(file5, 'wb')
    bytes = []
    totalframes = inaudio.getnframes()

    frame = unpack("<HH",inaudio.readframes(1))
    end = frame[0] | (frame[1] << 16)
    dist = (totalframes / end) - 1
    i=0
    while inaudio.tell()<totalframes and len(bytes) < end:
        frame = unpack("<hh",inaudio.readframes(1))
        side = (i % 2) == 0
        i += 1
        bytes.append(max(0, min(255, frame[0 if side else 1])))
        # skip frames
        inaudio.readframes(dist)

    inaudio.close()
    debytes = [b ^ random.getrandbits(8) for b in bytes]
    outmsg.write(bytearray(debytes))
    outmsg.close()

def checkformat(filename, expectedtype, expectedrate):
    if not os.path.isfile(filename):
        return False
    what = sndhdr.what(filename)
    # later: mp3 checking
    if what == None:
        return False
    ftype, rate, channels, frames, bps = what
    return ftype==expectedtype and rate==expectedrate

if __name__ == '__main__':
    main()
