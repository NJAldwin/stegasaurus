#!/usr/bin/env python
# coding=utf-8

# Group:    Stegasaurus
# Version:  0.01
# Date:     2012-2-17

# ==== Group Members ====
#  - Nick Aldwin <aldwin@ccs.neu.edu>
#  - Gary Katsevman <gkatsev@css.neu.edu>
#  - Alex Metzger <asm@ccs.neu.edu>
#  - Melissa Xie <emzee@ccs.neu.edu>

# ==== Usage ====
# see README

import sndhdr, wave, mimetypes, getopt, sys, os, random, subprocess
from struct import unpack, pack
from numpy.fft import fft, ifft
from numpy import int16
from bits import testbit, setbit

# Constants
DECODE = "decode" # Operation mode of the software
ENCODE = "encode"
WAV = "wav" # input type
RATE = 44100 # Sample rate (expected)
SEED = "our cool awesome seed" # Random number generator seed
FRAMEDIST = 7
LOW_MASK = 0x0000FFFF # Used for masking off the upper and lower segments of bytes
HIGH_MASK = 0xFFFF0000
UNIQUE_LEFT = -42 # Used when checking for steganographic payload
UNIQUE_RIGHT = 42
# FIXME: Make sure this path reflects the machine you're testing on
LAMEPATH = "/course/cs4500wc/Lame/src/lame-3.98.4/frontend/lame" # Path to LAME executable

def usage():
    """ Prints program usage and exits """
    print """./stegan --encode file1 file2 file3
./stegan --decode file4 file5
file1 → is input audio file, the carrier
file2 → is input message file
file3 → is output audio file
file4 → is input audio with steganography; i.e., file3
file5 → is output message file"""
    exit()

def main():
    """ Main operations """
    # Attempt to get the options the user provided
    try:
        mode, opts = getopt.getopt(sys.argv[1:],"",[DECODE,ENCODE])
    except:
        # if the command is improperly formed, print the usage
        usage()

    if len(mode) < 1:
        # if the mode isn't there, print the usage
        print "ERROR: No mode specified!"
        usage()

    # get the mode the user indicated
    mode = mode[0][0].strip('-')
    nargs = 3 if mode == ENCODE else 2

    # If the file has an mp3 extension
    if opts[0][-3:] == "mp3":
        # Convert it to wav
        convertmp3(opts[0])
        # change the filename's extension in the options array
        opts[0] = opts[0][:-4]+".wav"

    # check for appropriate number of arguments
    if len(opts) < nargs:
        usage()
    if not checkformat(opts[0], WAV, RATE):
        print "ERROR: File is of unexpected type!"
        usage()

    random.seed(SEED)   # seeds the random generator
    if mode == ENCODE:
        encode(opts) # calls encode on the arguments provided
    else:
        decode(opts) # calls decode on the arguments provided

def encode(opts):
    """ Encodes data into a file """
    print "Encoding..."
    file1, file2, file3  = opts # pull the individual values out of the opts array

    if not os.path.isfile(file2): # If the carrier doesn't exist, show the usage
        usage()

    # opens up the payload file and generate random bits
    tohide = open(file2, 'rb').read()
    bytes = bytearray(tohide)
    bits = []
    for b in bytes:
        for i in range(8):
            bits.append(testbit(b,i))
    prbits = [b ^ random.getrandbits(1) for b in bits]

    # copying the input audio's properties over to the output
    inaudio = wave.open(file1, 'rb')
    outaudio = wave.open(file3, 'wb')
    outaudio.setparams(inaudio.getparams())

    # Find the total number of frames in the input file
    totalframes = inaudio.getnframes()
    # The end of the file occurs at the end of the prbits array if it is shorter than the 
    # length of the original file. Otherwise, it is at the end of the original file.
    end = len(prbits) if len(prbits) * FRAMEDIST < totalframes else (totalframes/FRAMEDIST)
    # Separate the end of the file into the upper and lower 16 bits.
    endlo = end & LOW_MASK
    endhi = (end & HIGH_MASK) >> 16

    # skip frames for unique marking & length (first 2 frames hold metadata)
    inaudio.readframes(2)

    # Put the metadata into the first two frames
    # The first frame's two channels sum to 0, indicating there is data stored in the file
    # The second frame's two channels contain the length of the steganographic payload
    # some pack() usage notes:
    # < : little-endian
    # h : short
    # H : unsigned short
    outframe = pack("<hhHH", UNIQUE_LEFT, UNIQUE_RIGHT, endlo, endhi)
    outaudio.writeframes(outframe)

    # TODO: Convert this process to spread-spectrum
    # Calculate the distance to the end of the file
    dist = (totalframes / end) - 2
    # For each frame to the end of the file
    for i in range(end):
        frame = unpack("<hh", inaudio.readframes(1))
        freqs = fft(frame)
        side = (i % 2) == 0 # alternate channels
        freqs[0] = prbits[i] if side else freqs[0]
        freqs[1] = freqs[1] if side else prbits[i]
        newframes = ifft(freqs)
        #print "%s:%s:%s" % (frame,prbits[i],newframes)
        outframe = pack("<hh", newframes[0], newframes[1])
        outaudio.writeframes(outframe)
        frames = bytearray(inaudio.readframes(dist))
        outaudio.writeframes(frames)

    frames = bytearray(inaudio.readframes(totalframes))
    outaudio.writeframes(frames)

    outaudio.close()
    inaudio.close()

def decode(opts):
    """ Decode data from a file """
    print "Decoding..."
    file4, file5 = opts
    inaudio = wave.open(file4, 'rb')
    outmsg = open(file5, 'wb')

    # check unique
    check = unpack("<hh", inaudio.readframes(1))
    if not check[0]==UNIQUE_LEFT and not check[1]==UNIQUE_RIGHT and not check[0]+check[1]==0:
        print >>sys.stderr, "ERROR: No steganographic payload found."
        outmsg.close()
        usage()

    frame = unpack("<HH", inaudio.readframes(1))
    totalframes = inaudio.getnframes()
    end = frame[0] | (frame[1] << 16)
    dist = (totalframes / end) - 2
    bits = []
    i=0
    while inaudio.tell() < totalframes and len(bits) < end:
        frame = unpack("<hh", inaudio.readframes(1))
        side = (i % 2) == 0
        freqs = fft(frame)
        bits.append(freqs[0 if side else 1].astype(int16))
        inaudio.readframes(dist)        # skip frames
        i += 1
    inaudio.close()

    debits = [b ^ random.getrandbits(1) for b in bits]
    debytes = []
    for i in range(0,len(debits),8):
        byte = 0
        for j in range(8):
            if (debits[i+j] == 1):
                byte = setbit(byte, j)
        debytes.append(byte)

    outmsg.write(bytearray(debytes))
    outmsg.close()

def checkformat(filename, expectedtype, expectedrate):
    """ Check that the file is in the expected format """
    if not os.path.isfile(filename):
        return False

    header = sndhdr.what(filename)
    # later: mp3 checking
    if header == None:
        return False

    ftype, rate, channels, frames, bps = header
    return ftype==expectedtype and rate==expectedrate

def convertmp3(filename):
    if not os.path.isfile(filename):
        raise IOError('File not found')

    basename = filename[:-4]
    inputname = filename
    outputname = basename + ".wav"

    print "Converting "+inputname+" to "+outputname+"..."

    subprocess.call([LAMEPATH, "--decode", inputname, outputname])

if __name__ == '__main__':
    main()
